[TOC]
# 平时所研究的问题

##  location.href 进行跳转 

- `location.href="url"`可以用于本页面的跳转

## ajax中 serialize()提交表单数据

- jQuery ajax的serialize() 方法表单序列化为键值对（key1=value1&key2=value2…）
```html
    $.ajax({
        type: 'post',
        url: 'your url',
        data: $("form").serialize(), 
        success: function(data) {
            // your code
        }
    });
```

## reponsed.js解决IE6~8的响应式布局问题

- 媒体查询的支持程度是IE9+以及其他现代的浏览器
- !--[if lt IE 9]><script src = "http://cdn.bootcss.com/respond.js/1.4.2/respond.min.js"></script><![endif]--> 

- 基本的布局书写样式

```css
html,body {
    height: 100%;
}
@media only screen and (min-width: 480px){
    body {
        background: yellow;
    }
}
@media only screen and (min-width: 640px) and (max-width: 1024px) {
    body {
        background: green;
    }
}
@media screen and (min-width: 1024px){
    body {
        background: blue;
    }
}

```

## 关于立即执行函数表达式

### 保存闭包的状态

- 一个立即调用的函数表达式可以用来锁定值并且有效的保存此时的状态，因为任何定义在一个函数内的函数都可以使用外面函数传递进来的参数和变量(这种关系被叫做闭包)。

## 避免全局污染的一些措施

- 尽量少用全局对象
- 使用模块模式


## cookie到底是什么
-  cookie和session用于跟踪用户的整个会话,cookie通过在客户端记录信息确定用户身份,而session是在服务端记录信息确定用户身份的。
-  *一个用户的所有请求都同属于一个会话*,由于HTTP是无状态协议,一旦数据交换完毕,客户端与服务器端的连接就会断开,*如果再次请求数据会建立新的连接* **cookie就是跟踪这种会话的机制**

- 举个QQ空间的例子:
当我们登录QQ空间的时候，可以选择保存用户名和密码，这样下次登录的时候浏览器可以自动填充或者自动登陆，此时使用的是cookie技术，
```html
    将于http://qzone.qq.com/
```
 域名对应的cookie保存到硬盘中，下次访问的时候浏览器查找保存在硬盘中的与该域名对应的cookie填充。
 ②登录之后，我们可能做些操作，比如删除日志，发表说说，
 这些只有登录用户才能做的事情可以使用cookie也可以使用session进行会话跟踪

- **一般用cookie存储**

### cookie具有的属性
- cookie具有**不可跨域名性**,不同域名下的cookie不可相互影响,例Google只能操作google的cookie

### cookie的存储格式

- 正如上面所说，Cookie的存取方式有点类似于哈希表，是以名称作为索引存取的。一个Cookie的格式如下：
    - Cookie名称（作为Cookie的索引便于以后的各种操作）+“=”+Cookie值+“；expires=+有效期+“；path=”+路径+“；domain=”+域+“；secure=”+安全级别
    + 当存储中文的时候,需要encodeURI(“狗蛋狗蛋”) 
>  以"; """ 分号+一个空格分割

### Cookie 的属性选项

<h4>expires / max-age</h4>
`expires/max-age`都是控制cookie的有效期的,如果没有设置的话那么关闭浏览器就没有了

- <h5>expires</h5>
> `expires`选项用来设置Cookie的有效期<br>
方式:必须是GMT时间格式的(可以通过`new Data().toGMTString()`或者new Data().toUTCString()获得)

```javascript
    .get('/', (req, res) => {
  // 这个 Cookie 设置十秒后失效
  res.cookie('testName0', 'testValue0', {
    expires: new Date(Date.now() + 10000)
  })
  // 这个 Cookie 不设置失效时间
  res.cookie('testName1', 'testValue1')
  res.send('<h1>hello world!</h1>')
})
```

- <h5>max-age</h5>
> `expires` 是 http/1.0 协议中的选项，在新的 http/1.1 协议中 expires 已经由 `max-age` 选项代替，两者的作用都是限制 Cookie 的有效时间。expires 的值是一个时间点 (**Cookie 失效时刻 = expires**，而 max-age 的值是一个以秒为单位时间段 (**Cookie 失效时刻 = 创建时刻 + max-age**)

```javascript
app.get('/', (req, res) => {
  res.cookie('testName0', 'testValue0', {
    // express 这个参数是以毫秒来做单位的
    // 实际发送给浏览器就会转换为秒
    // 十秒后失效
    maxAge: 10000
  })
  res.cookie('testName1', 'testValue1')
  res.send('<h1>hello world!</h1>')
})

```
----------------

<h4>domain 和 path</h4>

> name、domain 和 path 可以标识一个唯一的 Cookie。domain 和 path 两个选项共同决定了 Cookie 何时被浏览器自动添加到请求头部中发送出去。具体是什么原理请看 Cookie 的作用域和作用路径 这个章节。
如果没有设置这两个选项，则会使用默认值。domain 的默认值为设置该 Cookie 的网页所在的域名，path 默认值为设置该 Cookie 的网页所在的目录。
- path一般设置为`path="/"`根目录下的所有网站都可以访问

<h4>secure</h4>
> `secure`选项用来设置 Cookie 只在确保安全的请求中才会发送。当请求是 HTTPS 或者其他安全协议时，包含 secure 选项的 Cookie 才能被保存到浏览器或者发送至服务器。 
> **不过默认情况下为空**,所以不管怎样都会被发出去

<h4>httpOnly</h4>
> 默认情况下为空,用来设置Cookie是否能通过js去访问 ,如果设置为`true`的话,则不能够用js去访问Cookie

###  客户端版设置cookie
```javascript
1. 设置从Cookie
document.cookie ="name=value"
//可以设置Cookie下列选项 :expires /domian /path / 
document.cookie='name=value; expires=Thu, 26 Feb 2116 11:50:25 GMT; domain=sankuai.com; path=/';

2. secure
//只有在https协议下才能生效

3. Cookie的属性都是唯一标识一个cookie的  只要覆盖掉原来的 设置max-age= 0就可以了
let removeCookie = (name, path, domain) => {
  document.cookie = `${name}=; path=${path}; domain=${domain}; max-age=0`
}
```
### 自我封装版本
```js
    function getCookie(key){
        var obj = {}
        var cookie =  document.cookie || '';   //获取到的是“ab=value1; key2=value2”格式的字符串
        var cookieArr = cookie.split("; ") //返回的是根式"; "分割成的数组[ab=value1,keu2=value2]
        for(var i = 0;i<cookieArr.length;i++){
            var item = cookieArr[i].split("=")
            obj[item[0]] = item[1]
        }
        return key?obj[key]:key
    }
```

## 了解JWT

> JWT声明一般被用来在身份提供者和服务器提供者间传递被认证的用户的信息,以便于从服务器获取资源

### 传统的session认证

http协议是一种无状态的协议,这就意味着当我们的用户向我们提供了用户信息进行验证了之后,下一次用户还需要认证一次,根据HTTP协议,我们并不能判断是哪个用户发出的请求,那么我们就需要**在服务器端保存一下用户的信息**,这份信息会在响应时**传递给浏览器**,告诉他**保存为cookie**,下次加载的时候通过存储的cookie与服务器中session进行比对,然后识别用户信息,  *但是扩展性不强,服务器不能承载更多的用户*

#### 存在的问题
```html
 1.服务器压力:用户信息通常是存储在服务器的内存中
 2.扩展性:保存在服务器内存中以为着用户的请求还必须是在指定的服务器上请求,限制了负载均衡
 3.安全性CSRF:session基于cookie 如果cookie被截获 黑客就可能伪造一份cookie进行攻击
```

### 基于token的鉴权机制

介绍下流程:
- 用户使用用户名和密码提交到服务器
- 服务器进行验证用户的信息
- 服务器通过验证给用户发送一个token
- 客户端存储token,并在每次请求中发送token
- 服务器验证token,并返回数据

### token怎么使用的
> 一般token字段可以存储在**localstorage**中 在需要使用的时候通过 ajax请求发送给服务器端验证

## 时间的转换

- 1. Date.parse(2014/11/01)  **可以转换成毫秒数**


# 解密浏览器

## 和浏览器客户端缓存相关的http请求

- Expires：过期时间
    + 表示在指定时间后浏览器缓存失效
    + 这里的时间必须是GMT格式的时间格式
    + 使用Expires过期时间要求服务器的时间必须是正确的

- Cache-Control:缓存控制
    + 控制缓存
    + 值分为：
        + 1.max-age=[秒]:类似于过期时间,是相对于请求时间的间隔时间
        + 2.s-max-age=[秒]:与max-age相似。除了它应用于共享
        + 3.public: **仅体现在响应头**,通知浏览器可以无条件的缓存,标记认证的内容也可以缓存
        + 4.private:**仅体现在响应头**,通知浏览器只针对单个用户缓存,并且可以具体指定某个字段;如`private-"username"`
        + 5.no-cache:**强制每次请求之间都发送给源服务器** ,而且不经过本地缓存版本的校验,不管是否过期,这对于需要确认认证应用很有用,*或者是那些严格使用最新数据的应用*
            + 请求头中: 告诉浏览器回去服务器取数据, 并验证你的缓存(如果有的话)
            + 响应头中: 告诉浏览器, 一定要回服务器校验, 不管有没有缓存数据. 如果确定没有修改, 可以使用缓存中的数据
        + 6.no-store:告诉浏览器任何情况下都不要被缓存
        + 7.must-revalidate/proxy-revalidate:告诉浏览器和缓存服务器,本地副本过期前,可以使用本地副本,一旦过期，需要去源服务器进行有效性校验

> e.g. cache-control:max-age=3600,must-revalidate <br/>
 @ 一般出现在**请求头**中的cache-control:表示浏览器通知服务器本地没有缓存数据<br/>
 @ 出现在**响应头**中的cache-control:表示服务器告诉浏览器xxx时间内别来烦我
- Last-Modified / If-Modified-Since(/If-Unmodified-Since)
    + Last-Modified:某个地址的最后修改时间,是服务器返回给客户端的信息
    + If-modified-Since:**是浏览器返回给服务器端的**：告诉服务器最后一个的缓存为什么时间修改的,然后服务器可以判断客户端缓存的这么url地址的缓存是否为最新的,如果是最新的,则会*返回给浏览器304状态码*,如果发现url最后更新的时间比当前时间要新,那么会输出新的内容.

- ETag/If-None-Match(比较ETag是否不一致)
    - **ETag**与Last-Modified相似,不过它是用来标识url的版本的,如果url变了那么它也会跟着变化,在浏览器发If-modified-match 时告诉浏览器内容已经变了,或者没变可以使用缓存
    - list会自动给静态文 件加上ETag,在文件发声改变时重新生成ETag,**这样对于一个网站的静态资源只需要下载一次就够了,可以减轻负载**
        + Yahoo 建议谨慎使用Etag ：Yahoo建议分布式系统尽量关闭掉Etag(每台机器生成的etag都会不一样，因为除了 last-modified、inode 也很难保持一致)。



### 浏览器的缓存机制
- 浏览器有两种缓存规则
    + 1. 强制缓存
    + 2. 对比缓存
```html
    1.首先要说明的是:强制缓存的优先级要高于对比缓存
    也就是说,在执行强制缓存时,如果缓存生效,那么直接
    使用缓存,不进行对比缓存


    2.浏览器第一次返回数据的数据的时候,会把缓存标识和数据
    一并发送到客户端,客户端将二者缓存到本地
    第二次请求的时候,客户端将缓存的标识发送给服务器
    服务器会根据缓存的标识进行判断：
    如果Last-Modified>If-modified-since:那么返回200 重新下载
    如果Last-Modified>If-modified-since:那么返回304 使用缓存

(优先级高于Last-modified)  如果比对ETag不用,那么返回200,重新下载资源
    如果比对Etag相同,那么返回304,使用缓存
```
> 即当本地副本根据Cache-Control/Expires发现还在有效期内时，则不会再发送请求去服务器询问修改时间（Last-Modified）或实体标识（ETag）了


<h3>1.第一次请求</h3>
![](./imgs/cache.jpg)

<h3>2.第二次请求</h3>
![](./imgs/cache2.jpg)

<h3>3.另一个清晰解释</h3>
![](./imgs/cache-3.jpg)


### 如果用户手动操作
> 通常来说,当用户**按下F5**进行刷新的时候,会忽略Cache-Control/expires, 会再次发送请求去服务器请求 (携带ETag/if-modified-since),服务器决定返回304还是200<br/>
而当用户按下ctrl+f5进行强制刷新的话,所有的缓存机制都将失效,所有资源重新去服务器重新请求


