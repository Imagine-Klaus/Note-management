<!-- 鼠标键盘事件 -->
  event.keycode 键盘码
  onmouseup 鼠标弹起
  onmousedown 鼠标按下
  onmouseover 鼠标经过
  onmouseout 鼠标离开 // onmouseleave(不兼容,阻止向上冒泡)
  onblur 失去焦点
  onfocus 获取焦点
  onkeypress 键盘按压 
  onkeyup 键盘弹起事件  
  onkeydown 键盘按下事件
  ondblclick 鼠标双击
  onclick  鼠标单击
  onresize 事件会在窗口或框架被调整大小时发生
  onscroll 滚动条滚动事件
  oninput 在输入的时候执行
  onchange 失去焦点后如果表单元素的内容发生了改变 这个时候就会执行
  鼠标在页面上移动: document.onmousemove

mouseover与mouseenter
不论鼠标指针穿过被选元素或其子元素，都会触发 mouseover 事件。
只有在鼠标指针穿过被选元素时，才会触发 mouseenter 事件。


offset系列
 offsetX/poffsetY  X/Y的偏移量
例子:   document.querySelector('.progress').onclick = function (e){
              console.log(e.offsetX)
        }
        e.offsetX 为点击时的水平位置相对于progress原始位置的偏移量

 
.offsetHeight = height+padding+border  没有单位,就近取
.style.height = height   有单位,只能获取行内样式
总结:一般用xx.offsetLeft来获取某元素的真实宽度/高度，用.style.left来设置宽度/高度

.offsetParent  返回该对象 距离最近的 带有定位的 父级  所有父级无定位为body
.parentNode    只找自己的上一级

.offsetLeft .offsetTop
到距离自身最近的（带有定位的）父元素的 左侧/顶部 的距离
从子盒子border左侧(不包括 b)到父盒子border右侧(不包括b)
无定位  子盒子border左侧到body

@offsetLeft和style.left的区别
一、style.left只能获取行内样式
二、offsetLeft只读，style.left可读可写
三、offsetLeft是数值，style.left是字符串并且有单位px
四、如果没有加定位，style.left获取的数值可能是无效的
五、最大区别在于offsetLeft以border左上角为基准，style.left以margin左上角为基准


Math对象
Math.ceil()  向上取整   Math.ceil(-2.1) == -2
Math.floor() 向下取整   Math.ceil(-2.1) == -3
Math.round() 四舍五入(0.5取大的)   Math.round(-1.5) == -1  Math.round(1.5) == 2
Math.abs()   取绝对值   Math.abs(-2.1) == 2.1


轮播图原理: 从倒数第二张图过渡到最后一张,当全部显示最后一张图片时,直接跳转到第一张图片,然后从第一张图片过渡到第二张图片
<!-- 完整轮播图
1.动态生成结构
    1.1根据图片数量动态生成右下角方块li按钮   document.createElement("")   .innerHTML  .appendChild()
    1.2克隆第一张图放到最后  .cloneNode(ture)  .appendChild()
2.鼠标经过按钮
    2.1鼠标经过按钮 按钮排他   onmouseover  for遍历  className
    2.2把动画封装函数复制到最后   function animate(obj, target) {...}
    2.2给按钮添加索引,以动画的形式把ul移动到指定的位置   index   imgWidth  移动动画:animate(ul, target)
3.鼠标点击箭头
    3.1鼠标经过盒子 显示箭头 鼠标离开盒子 隐藏箭头     .style.display
    3.2点击左右箭头 以动画的形式把ul移动到指定的位置     移动动画:animate(ul, target)
        3.2.1先判断 如果是最后一个图片 先让ul瞬间跳回开始位置 然后索引也要归零   .style.left   pic++
        3.2.2先判断 如果是第一个图片 先让ul瞬间跳到最后的位置 然后索引也要到最后  ulLis.length-1  pic- -
4.设置自动播放
    timer = setInterval(right.onclick, 1000) ???
5.方走块按钮需要跟着
    5.1设置对应的square值   在left/right.onclick里面设置square值   if判断条件  square++
    5.2点击左右箭头 方块按钮也切换  olLis[square].className = "current"
6.把所有索引统一
    pic = this.index;    square = this.index; -->



<!-- day  02 -->
<!-- attr 属性名 -->
json {属性名:属性值} {attr:target}
获取行内对象的属性
console.log(demo.style["属性名"])
console.log(demo.style.属性名)

获取计算后样式的属性
window.getComputedStyle(obj, null)[attr]  chrome兼容
obj.currentStyle[attr]  ie兼容
属性名要加括号,属性值通常是加单位px的数字
特殊情况只有纯数字(opacity zIndex index offseLeft offsetWidth)

parseInt() 函数可解析一个字符串,并返回一个整数
             


<!-- day  03 -->
onresize 事件会在窗口或框架被调整大小时发生

偏移.offsetWidth: width  +  padding  +  border 
卷曲.scrollWidth: width  +  padding  不包含border   内部内容的大小(大于等于clientWidth)
可视.clientWidth: width  +  padding  不包含border   可视区的大小(不包括溢出盒子的内容)

.offsetLeft .offsetTop    从子盒子border左侧(不包括b)到带定位的父盒子border右侧(不包括b,无定位时父盒子是body)
.scrollLeft .scrollTop(需要封装)返回或设置匹配元素的滚动条的水平位置
<!-- 封装获取页面滚动距离 -->
var scrollTop = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop(兼容ie 8) || 0;
var scrollLeft = pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft || 0;
<!-- 封装获取可视化宽高 -->
var clientWidth = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth || 0;
var clientHeight = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight || 0;

event.pageX      event.pageY     鼠标在整个页面中的坐标
event.clientX    event.clientY   鼠标在窗口(可视区)中的坐标
event.screenX    event.screenY   鼠标在屏幕中的坐标
<!-- 页面坐标兼容 -->
var pageX = event.pageX || event.clientX + document.documentElement.scrollLeft
var pageY = event.pageY || event.clientY + document.documentElement.scrollTop  

单词:
assign 分配 event事件  page页面 screen屏幕 target目标 client客户端 server服务端 mask遮罩
range范围 empty空的 propagation传播  bubble泡泡  config配置布局   responsive响应式
regular expression digit word space form feed table vertical replace trim object orented programming prototype 



<!-- day  04 -->
防止拖拽时选中文字
window.getSelection ? window.getSelection().removeAllRanges() : document.selection.empty();

阻止事件的冒泡--向上传播
    1.先获取事件对象  event
    2.event.stopPropagation() || cancelBubble = true;

事件目标(触发事件的源头)
var target = event.target || event.srcElement;
console.log(target.id)

注册事件新方式:
1.btn.onclick = function () {...}
2.btn.addEventListener( "click" , function(){...} , false )<!-- (不加on) -->
移除事件新方式:
1.btn.onclick = null   只能清除注册1
2.btn.addEventListener("click",null,false)  只能清除上面的注册1方式
3.btn.removeEventListener("click",fn,false) 清除所有注册事件方式
备注:addEventListener便于管理事件队列 但一般用on的就可以了比较简单
<!-- 兼容IE
btn.attachEvent( "onclick" , function(){...})  添加事件
btn.datachEvent( "onclick" , fn )              移除事件 -->
<!-- 捕获:
false  冒泡顺序  从小(事件)到大冒泡阶段3 再到目标阶段2
true   捕获顺序  从大(事件)到小捕获阶段1 再到目标阶段2
enent.eventPhase 
打印1就是捕获阶段 ， 打印2就是目标阶段 ， 打印3就是冒泡阶段 -->
event.keyCode  键盘编码
onchange 失去焦点后如果表单元素的内容发生了改变 这个时候就会执行



<!-- day  05 -->
正则表达式 regEx (/切记里面不能加空字符串,不然会运行错误/):
a) 通过构造函数创建 var regEx = new RegExp( /\d/ )
b) 通过字面量       var regEx2 = /\d/

/[abc]1/  ===  /(a|b|c)1/  a或b或c
------简单类------
/chuan/.test("chuang")  false  只要有我想要的就可以
/[abc]/.test("da")  true
------负向类------
/[^abc]/.test("da")  true 
/[^a-z0-9]/    非a-z且非0-9
------范围类------
/[abcdefghi]/
/[a-i]/
------组合类------
/[a-kA-N0-5]/

/^a/ 和 [^a] 的区别:
中括号里面写^表示 非 !!!!!慎重用非!!!!
中括号外面写^表示 限制开头

边界:
^ 表示限制开头
$ 表示限制结尾
    /^chuan$/.test("chuang"))        true
    /^chuan$/.test("chuanchuan"))    false

量词:
* 表示a可以出现0次或者多次 x >= 0
"+" 重复一次或更多次 x >= 1
"?" 重复零次或一次  x = (0||1)
    /^a*$/.test("aaaaaa") true
    /^a*$/.test("")  true
    /^a+$/.test("")   false
    /^a?$/.test("aaa"))  false

{} 自定义出现的次数
    /^a{2}$/.test("aa")   a可以出现2次 a=2
    /^a{2,}$/.test("aa")   a可以出现2次或者更多 a>=2
    /^a{2,5}$/.test("aa")    a可以出现2次到5次 a>=2并且<=5

{} 是量词 用来修饰前面内容出现的次数
    /^a{2}$/.test("aa")
[] 表示一个字符的位置
    [abc]代表一个字符:a或b或c
() 用来分组 可以提高优先级
    /^chuan$/.test("chuan")
    /^chuan{2}$/.test("chuanchuan")
    /^chuan{2}$/.test("chuann")
    /^(chuan){2}$/.test("chuanchuan")

正则表达式验证电话密码姓名等
check( inpTel , /^(13[0-9]|14[57]|15[0-9]|17[1456789]|18[0-9])\d{8}/ )
check( inpName , /^[\u4e00-\u9fa5]{2,6}$/ )
check( inpPassword , 自己百度 )
check( inpQQ , /^[1-9]\d[4,11]$/ )
var regEmail = /^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$/

\. 表示.
.  表示除了回车换行以外的任意字符

错误 \w  表示 所有字母数字的和(单词字符为一个 例:\w == abc12AS )
正确 \w == [a-zA-Z0-9_]  为一个字符   多个需要\w+


字符串的replace方法
str = str.replace("1", "a")
str = str.replace(/\d/g, "a")   g global 全局  替换所有数字字符为a
去掉两端的空白符
str = str.replace(/^\s+|\s+$/g, "")
str = trim(str);