<!-- 
ctrl+shift+L 删除
ctrl+shift+J 复制一行
ctrl+D 浏览器打开
ctrl+F 查找
F3 查找下一个
shift+F3 查找上一个
ctrl+R 替换
ctrl+shift+R 全部替换 -->

半透明:
background-color: gray;
/*优雅降级,兼容IE 6 7 8*/
background-color: rgba(0,0,0,.3);
/*0 0 0是黑色 , 0.3是背景透明程度(0-1之间)*/
<!-- opacity:0.3 全部透明,包括里面文字 不兼容IE 6-8 
filter: alpha(opacity= 20) 兼容IE 6-8 (0-100) -->

引入ico图标
代码：  <link rel="shortcut icon" href="favicon.ico"  type="image/x-icon"/>ico图标为了兼容性，我们放到根目录下。
Description 网站说明
<meta name="description" content="" />
Keywords 关键字
<meta name="keywords" content="" />
white-space: nowrap   不允许文字换行;


BFC("块级格式化上下文")
是一个独立的渲染区域,只有块级盒子参与,规定了内部的块级盒子如何布局,它与区域外部毫不相干

添加如下属性可以触发BFC:
1. float浮动
2. position: absolute  fixed 
3. display: inline-block
4. overflow: hidden

BFC元素具有的特性
1. BFC里的标准流盒子从顶端开始竖直地一个个排列
2. 盒子垂直方向距离由margin决定,属于同一个BFC的两个相邻盒子的上下margin会发生重叠
3. 在BFC中,每个盒子的左外边距(margin-left)会触碰容器的左边框(border-left)
4. BFC的区域不会与浮动盒子产生交集,而是紧贴浮动边缘(是区域外的浮动盒子,运用于自适应盒子)
5. 计算BFC的高度时,自然也会检测浮动的盒子高度

BFC的主要用途
1. 清除浮动
2. 外边距合并问题
3. 制作右侧自适应的盒子问题


<!-- 数学运算符:
    console.log (5 / 0)  //Infinity
    console.log (0 / 0)    //NaN
    console.log (5 % 0)    //NaN
    console.log (5 % 6)  //结果为5

逻辑运算符:
前面 && 后面 (返回决定性的值)
// 前面的值如果是false,返回前面
// 前面的值如果是ture, 返回后面

前面 || 后面 (返回决定性的值)
// 前面的值如果是false,返回后面
// 前面的值如果是ture, 返回前面

赋值运算符:
a+=b 等价于 a=a+b
 -->
运算符的优先级:
( ) 优先级最高

boolean型:会转化成false的值有: 空字符串"" 数值0 NaN undefined null false
<!-- 对象转化为布尔值都是true,包括空对象 -->
undefined  表示声明但未赋值的变量	

字符串的不可变性
优化:用数组拼接,再转化为字符串
var arr = [];
for (var i = 0; i < inputs.length; i++) {
    arr.push(inputs[i].value);
}
console.log(arr.join(""));

转化为字符型:
1. String(123) 转化 
2. 123 + "" (空字符串) 
<!--  使用 123.toString() 
注意:  none 和 undefined 不能转化 -->

转化为数值型:
1.  var num = + "123" || "123" - 0
2. Number(ture)为 1 
   Number(false)为 0
   Number(null)为 0
   Number(underfined)为 NaN
   Number("12px") 为NaN,属于number	
<!-- 在转化为字符串时,只要有不认识的就返回NaN
parseInt() 输出认识的整数数值.忽略小数,parseInt(12px) 为 12 ,parseFloat 输出认识的数值.包含小数 
 -->
数组的遍历(快捷键itar+Tab):
for (var i =0 ; i < arr.length ; i++) {
	console.log(arr[i]);
}

反向数组遍历:
for (var i = arr.length-1 ; i >= 0 ; i--) {
	console.log(arr[i]);
}

数组添加元素:
arr[arr.length]= "添加的元素";

var arr = [1, 2, 3, 4, 5];
输出数组形式
console.log(arr.valueOf());返回数组对象本身
console.log(arr.toString());
console.log(arr.join("-"));把逗号换成其他符号拼接字符串
检测数组
console.log(typeof arr);	
console.log(arr instanceof Array);
console.log(Array.isArray(arr));
添加删除元素
arr.push(5,6,7)     从后面添加元素 返回新数组的长度(可以直接改变旧数组)
arr.pop()           从后面删除元素 返回被删除的元素
arr.shift()         从前面删除元素 返回被删除的元素
arr.unshift(0,1)    从前面添加元素 返回新数组的长度
arr.reverse()       反转数组,改变原来数组
查找数组中元素
arr.indexOf("a")        以索引0计数从前往后找,返回索引号,找不到返回 -1
arr.lastIndexOf("b")    从后往前找,返回索引值(详寻视频04 13)
arr.slice(0, 2)         1开始 2结束 [start,end) 开始能取到 结束取不到 不会改变原数组
arr.splice(0, 2,"a")    1开始的位置 2删除的个数 3要加入的元素(可以不添加),会对原数组进行修改,删除元素，并向数组添加新元素。        
arr.join()         将数组拼接成字符串,默认是"," join("") 字符间无连接

es5迭代方法: 
element代表当前遍历的元素)
index代表当前遍历元素的索引值
array代表当前要遍历过滤的数组

数组的遍历(对原数组无影响)
var arr = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
var NewArr = arr.forEach(function(element,index,array) {
    console.log(element);})

var NewArr = arr.filter(function (element, index, array) {
        if (element > 2000) {
            return false;
        }
        return true;                        
    });
回调函数(callback):
用来测试数组的每个元素的函数,调用时使用参数(element,index,array),返回true表示保留该元素,false不保留


基本(值)数据类型的数值存放在栈里面
引用复杂数据类型,栈中储存地址,堆中储存真实数据地址

函数也是一种普通的数据类型
被当作参数传递的函数叫做回调函数

递归调用:
程序调用自身的编程技巧称为递归

对象的声明
1. var obj= new Object();
2. var obj= {};
对象字面量:
var obj = {
	name:"jutian",
	age:18,
	move:function() {
		console.log("跳舞")
	}
}

数组的声明
1. var arr = new Array("a", "b", "c");
2. var arr = ["a","b","c"];
	arr[3] = 4;

对象的调用(访问属性)
1. obj.age = 18;
2. obj["age"] = 18;
var stu = {name: "zx",age:18}
console.log(stu.age);
console.log(stu["name"])
属性名称要用引号包裹,相当于字符串
注意:可以访问动作obj["move"],但不可以返回值obj["move()"]

对象的有序遍历(不能用于数组):
for (var k in obj) {
        console.log(obj[k]);
    }


返回值详解:
1.代码执行到return关键字后 会跳出当前函数 后续代码不再执行
2.函数的返回值是什么调用这个函数就相当于调用了什么
3.没有返回值的函数相当于返回了undefined
4.return可以不返回值,仅仅用来结束函数
<!-- var count = 1 ;
function test(){
	count++;
	if(count>=3){
		return;
	}
	console.log("函数运行了");
}
test(); count 0  函数运行了
test(); count 1  函数运行了
test(); count 2  函数运行了
test(); count 3  不显示 "函数运行了" -->

<!-- this的几种用法 -->
1.全局上下文（在所有函数的外部） this指的是全局对象window
2.函数上下文（在某个函数的内部） this指的是当前函数所属的对象



形参和实参的个数可以不一致:
function getSum(a,b) {return a + b ;}
var num =getSum(1,2,3) 为3;
var num =getSum(1) 为NaN;

局部变量只能在函数中使用,不能在函数外部使用
function getSum() {var a=100;return a + b ;}
console.log(a) a未被定义

不在函数中定义的变量是全局变量
if (2>1) {
	var a = 3 ;
}
console.log(a);
括号不影响a的定义,依然是全局变量


<!-- DOM   01 -->
DOM---(Document Object Model))
事件绑定的时候,事件处理程序执行吗? 不执行  事件被触发的时候才执行
替换类名方法的封装:
使用：replace方法,替换后返回新的字符串
function replaceClassName(ele, oldStr, newStr) {
	ele.className = ele.className.replace(oldStr，newStr);
}


onmousemove  鼠标移动时自动触发
onresize 事件会在窗口或框架被调整大小时发生
onmouseover 鼠标经过
onmouseout 鼠标离开
onblur 失去焦点
onfocus 获取焦点
onkeyup 键盘弹起事件  
onkeydown 键盘按下事件
ondblclick 鼠标双击
onclick  鼠标单击

阻止浏览器默认行为:
在标签行内属性中设置：return false
<a onclick="return false;"></a>
getELementsByTagName 可以被普通的元素对象调用,表示获取这个元素对象内部的这一类型的标签
获取的是若干元素的集合：伪数组
document.getELementsById 不可以被普通的元素对象调用,表示获取ID


注册事件: 获取img标签 然后 控制他的src属性
<img src="..." id="demo" onclick="changePic()">
function changePic() {
	var demo = document.getElementById("demo");
	demo.src = "images/tiger.png"
}	

引用类型做参数:
规律总结:有NEW就在堆里面创造新的对象,形参p和实参p一般情况不同
前面加new关键字(当一个函数被作为构造函数使用时)
1.创建出来一个空对象
2.把this指向这个空对象
3.在函数运行完成后 隐式的把this返回


<!-- DOM   02 -->
console.dir  查看对象的属性

innerHTML "获取内部的html",会把原内容清空
innerText "获取内部的文本内容,html标签会被忽略",会把原内容清空(兼容问题,需封装)
textContent(火狐) 作用同innerText(IE支持)
<!-- box.innerHTML = "<h1>title</h1>";如果是符合标签规则的文本会变成标签
box.innerText = "<h1>title</h1>"	;即使是符合标签规则的文本会变成纯文本 -->

<!-- 用if检测浏览器支持的属性 -->
如果一个对象有某个属性 获取到的值是string
如果一个对象没有某个属性 获取到的值是undefined
<!-- if (typeof box.innerText === "string") {
        console.log(box.innerText);
} else {
        console.log(box.textContent);
  } -->


<!--   禁用文本框 -->
  disabled = true ||  disabled = "disabled"
  <!-- 点击禁用文本框 -->
  btn.onclick = function () {
        input.disabled = true
  };

  <!-- 点击按钮选中D选项 -->
  btn.onclick = function () {
        d.selected = true;
        d.checked = true;<!-- 或者 -->
  };


<!-- 标签的自定义属性: -->
原始:<div id = "box" a="1" class="2"></div></div>

控制台打印自定义属性
console.log(box.class) = "2"
console.log(box.a) = "undefinded"

添加box.title = "3"  
转变<div id = "box" a="1" class="2" title="3"></div></div>
标准中有规定的属性,对象中属性的设置会改变标签

添加box.c = "4"  标准中没有规定的属性,对象中属性的设置无法映射到标签上
未变<div id = "box" a="1" class="2"></div></div>


<!-- 专门用来操作标签属性的方法: -->
获取getAttribute <!-- 任何标签中的属性都可以获取 -->
box.getAttribute("a");//可以获取没有规定的属性
<!-- box.getAttribute("id");//也可以获取有规定的属性 -->

设置setAttribute <!-- 任何标签中的属性都可以设置 -->
box.setAttribute("b", "2");//可以设置没有规定的属性
<!-- box.setAttribute("class", "cls");//可以设置有规定的属性 -->

移除removeAttribute <!-- 任何标签中的属性都可以移除 -->
box.removeAttribute("a");
<!-- box.removeAttribute("class"); -->


<!-- DOM   03 -->
<!-- node : 元素 -->
判断元素节点: xx.nodeType === 1
判断节点类型: xx.nodeType === 1(3,8,2)  
打印节点的值: console.log(xx.nodeValue) 
获取节点名称: console.log(xx.nodeName) <!-- #text #comment-->

节点:元素节点1(标签)   文本节点3    注释节点8    属性节点2

子节点: xx.childNodes 包含任意节点,是伪数组,需要遍历取出单个节点(不包括li里面的li) 
父节点: xx.parentNode 是元素节点

子元素节点(标签): xx.children  
通过children获取的是伪数组,而不是元素,不能children.className = "xx"
解决方法: children[0].className = "xxx";
getNextElement(this).innerHTML = "密码必须在3-6位之间";

连写:var inputs = document.getElementById("box").getElementsByTagName("input");

 box.style.left = "200px";
 box.style.top = "200px";
 注意:盒子必须要绝对定位或固定定位


总的说明:
子节点: xx.childNodes
父节点: xx.parentNode
子元素节点(标签): xx.children
父元素节点: xx.parent  
兄弟节点:  nextSibling 
下一个兄弟元素:  nextElementSibling  <!-- (兼容问题,需封装) -->
上一个兄弟节点:  previousSibling
上一个兄弟元素:  previousElementSibling
最后一个兄弟节点:  lastSibling
最后一个兄弟元素:  lastElementSibling
第一个子节点:  firstChild
第一个子元素:  firstElementChild
最后一个子节点:  lastChild
最后一个子元素:  lastElementChild


 <!-- 前端基本功05 -->
window.alert()
window.prompt()
window.confirm()
他们都属于window window可以省略

window.onload 窗体加载完成 页面结构和外部资源都加载完成

打开窗口:<!--1.地址 2.在哪里打开("_self","_blank") 3.窗口的属性-->
win = window.open("http://www.baidu.com", "_blank", "width=200,height=200");
关闭窗口:win.close()

location对象
console.log(window.location.hash);//锚点
console.log(window.location.host);//主机 主机名+端口号
console.log(window.location.hostname);//主机名
console.log(window.location.pathname);//路径名
console.log(window.location.port);//端口
console.log(window.location.protocol);//协议
console.log(window.location.search);//一些参数

window.navigator
console.log(navigator.userAgent);//可以获取客户端的一些信息

history.forward();
history.back();

console.log(screen.width);//宽度
console.log(screen.height);//高度
console.log(screen.availWidth);//可用宽度
console.log(screen.availHeight);//可用高度


