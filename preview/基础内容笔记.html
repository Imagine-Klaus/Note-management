<html>
  <head>
	  <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>i5ting_ztree_toc:基础内容笔记</title>
		<link href="toc/style/github-bf51422f4bb36427d391e4b75a1daa083c2d840e.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/style/github2-d731afd4f624c99a4b19ad69f3083cd6d02b81d5.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/zTreeStyle/zTreeStyle.css" media="all" rel="stylesheet" type="text/css"/>
	  <style>
		pre {
		    counter-reset: line-numbering;
		    border: solid 1px #d9d9d9;
		    border-radius: 0;
		    background: #fff;
		    padding: 0;
		    line-height: 23px;
		    margin-bottom: 30px;
		    white-space: pre;
		    overflow-x: auto;
		    word-break: inherit;
		    word-wrap: inherit;
		}

		pre a::before {
		  content: counter(line-numbering);
		  counter-increment: line-numbering;
		  padding-right: 1em; /* space after numbers */
		  width: 25px;
		  text-align: right;
		  opacity: 0.7;
		  display: inline-block;
		  color: #aaa;
		  background: #eee;
		  margin-right: 16px;
		  padding: 2px 10px;
		  font-size: 13px;
		  -webkit-touch-callout: none;
		  -webkit-user-select: none;
		  -khtml-user-select: none;
		  -moz-user-select: none;
		  -ms-user-select: none;
		  user-select: none;
		}

		pre a:first-of-type::before {
		  padding-top: 10px;
		}

		pre a:last-of-type::before {
		  padding-bottom: 10px;
		}

		pre a:only-of-type::before {
		  padding: 10px;
		}

		.highlight { background-color: #ffffcc } /* RIGHT */
		</style>
  </head>
  <body>
	  <div>
				<div style='width:25%;'>
						<ul id="tree" class="ztree" style='width:100%'>

						</ul>
				</div>
        <div id='readme' style='width:70%;margin-left:20%;'>
          	<article class='markdown-body'>
            	<h1 id="-">基础内容笔记整理</h1>
<h2 id="-html">关于HTML</h2>
<h3 id="1-html-">1 HTML中常见的面试题</h3>
<h4 id="-url-">当你在浏览器地址栏输入URL,按下回车后究竟发生了什么?</h4>
<p><a href="http://blog.csdn.net/bruce_6/article/details/39499439">链接跳转</a></p>
<h4 id="-">浏览器的渲染过程</h4>
<ul>
<li><p>1、Create/Update DOM And request css/image/js：浏览器请求到HTML代码后，在生成DOM的最开始阶段（应该是 Bytes → characters 后），并行发起css、图片、js的请求，无论他们是否在HEAD里。</p>
<p>  <strong>注意：发起js文件的下载request并不需要DOM处理到那个script节点，比如：简单的正则匹配就能做到这一点，虽然实际上并不一定是通过正则：）。这是很多人在理解渲染机制的时候存在的误区</strong></p>
</li>
<li><p>2、Create/Update Render CSSOM：CSS文件下载完成，开始构建CSSOM</p>
</li>
<li><p>3、Create/Update Render Tree：所有CSS文件下载完成，CSSOM构建结束后，和 DOM 一起生成 Render Tree。</p>
</li>
<li><p>4、Layout：有了Render Tree，浏览器已经能知道网页中有哪些节点、各个节点的CSS定义以及他们的从属关系。下一步操作称之为Layout，顾名思义就是计算出每个节点在屏幕中的位置。</p>
</li>
<li><p>5、Painting：Layout后，浏览器已经知道了哪些节点要显示（which nodes are visible）、每个节点的CSS属性是什么（their computed styles）、每个节点在屏幕中的位置是哪里（geometry）。就进入了最后一步：Painting，按照算出来的规则，通过显卡，把内容画到屏幕上。</p>
</li>
</ul>
<blockquote>
<p>以上五个步骤前3个步骤之所有使用 “Create/Update” 是因为DOM、CSSOM、Render Tree都可能在第一次Painting后又被更新多次，比如JS修改了DOM或者CSS属性。</p>
<p>Layout 和 Painting 也会被重复执行，除了DOM、CSSOM更新的原因外，图片下载完成后也需要调用Layout 和 Painting来更新网页。</p>
</blockquote>
<h4 id="-">常见的浏览器内核有哪些？</h4>
<ul>
<li><strong>Trident内核</strong>：IE,MaxThon,TT,The World,360,搜狗浏览器等。[又称MSHTML]</li>
<li><strong>Gecko内核</strong>：Netscape6及以上版本，FF,MozillaSuite/SeaMonkey等。</li>
<li><strong>Presto内核</strong>：Opera7及以上。      [Opera内核原为：Presto，现为：Blink;]</li>
<li><strong>Webkit内核</strong>：Safari,Chrome等。   [ Chrome的：Blink（WebKit的分支）]</li>
<li><strong>EdgeHTML内核</strong>：Microsoft Edge。  [此内核其实是从MSHTML fork而来，删掉了几乎所有的IE私有特性]</li>
</ul>
<h4 id="-html-">简述一下你对HTML语义化的理解。</h4>
<ul>
<li>1.0用正确的标签做正确的事情。</li>
<li>2.0HTML语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析；</li>
<li>3.0即使在没有样式CSS的情况下也能以一种文档格式显示，并且是容易阅读的；</li>
<li>4.0搜索引擎的爬虫也依赖于HTML标记来确定上下文和各个关键字的权重，有利于SEO；</li>
<li>5.0使阅读源代码的人更容易将网站分块，便于阅读、维护和理解。</li>
</ul>
<h4 id="-link-import-">页面导入样式时，使用Link和@import有什么区别？</h4>
<ul>
<li>（1）link属于XHTML标签，除了加载CSS外，还能用于定义RSS, 定义rel连接属性等作用；<em>而@import是CSS提供的，只能用于加载CSS</em>;</li>
<li>（2）页面被加载的时，link会同时被加载，而@import引用的CSS会<em>等到页面被加载完再加载</em>;</li>
<li>（3）<strong>import</strong>是CSS2.1 提出的，只在<strong>IE5</strong>以上才能被识别，而link是XHTML标签，无兼容问题;    </li>
</ul>
<h4 id="-">介绍一下你对浏览器内核的理解</h4>
<ul>
<li>主要分成两部分：渲染引擎(layout engineer或Rendering Engine)和JS引擎。
  +（1）渲染引擎：负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入CSS等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核。
  +（2）JS引擎则：解析和执行javascript来实现网页的动态效果。<blockquote>
<p>最开始渲染引擎和JS引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎。</p>
</blockquote>
</li>
</ul>
<h4 id="doctype-">Doctype作用？标准模式与兼容模式各有什么区别？</h4>
<ul>
<li>（1）&lt;!DOCTYPE&gt;声明位于HTML文档中的第一行，处于html标签之前，用于告知浏览器的解析器用什么文档标准解析这个文档。DOCTYPE不存在或格式不正确会导致文档以兼容模式呈现。</li>
<li>（2）标准模式的排版和JS运作模式都是以该浏览器支持的最高标准运行。在兼容模式中，页面以宽松的向后兼容的方式显示，模拟老式浏览器的行为以防止站点无法工作。</li>
</ul>
<h4 id="html5-html5-html-html5-">HTML5有哪些新特性、移除了哪些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和 HTML5？</h4>
<ul>
<li>HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加。</li>
<li>绘画 canvas;</li>
<li>用于媒介回放的 video 和 audio 元素;</li>
<li>本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失;</li>
<li>sessionStorage 的数据在浏览器关闭后自动删除;</li>
<li>语意化更好的内容元素，比如 article、footer、header、nav、section;</li>
<li>表单控件，calendar、date、time、email、url、search;</li>
<li>新的技术webworker, websockt, Geolocation;</li>
</ul>
<h4 id="-cookies-sessionstorage-localstorage-">请描述一下 cookies，sessionStorage 和 localStorage 的区别？</h4>
<ul>
<li><code>cookie</code>是网站为了标识用户身份而储存在用户本地终端（Client Side）上的数据（通常已经过加密）。cookie数据始终在同源的http请求中携带（即使不需要），也会在浏览器和服务器间来回传递。</li>
<li><p><code>sessionStorage</code>和<code>localStorage</code>不会自动把数据发给服务器，仅在本地保存。</p>
</li>
<li><p>存储大小：</p>
<ul>
<li>cookie数据大小不能超过4K。</li>
<li>sessionStorage和localStorage虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。</li>
</ul>
</li>
<li>有效时间：<ul>
<li>cookie          设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭</li>
<li>sessionStorage  数据在当前浏览器窗口关闭后自动删除</li>
<li>localStorage    存储持久数据，浏览器关闭后数据不丢失除非主动删除数据</li>
</ul>
</li>
</ul>
<h4 id="iframe-">iframe 有哪些缺点？</h4>
<ul>
<li>iframe会阻塞主页面的Onload事件；</li>
<li>搜索引擎的检索程序无法解读这种页面，不利于SEO；</li>
<li>iframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。</li>
<li>使用iframe之前需要考虑这两个缺点。如果需要使用iframe，最好通过JavaScript动态给iframe添加src属性值，这样可以绕开以上两个问</li>
</ul>
<h4 id="html5-">HTML5 应用程序缓存和浏览器缓存有什么区别？</h4>
<blockquote>
<p>应用程序缓存是 HTML5 的重要特性之一，提供了离线使用的功能，让应用程序可以获取本地的网站内容，例如 HTML、CSS、图片以及 JavaScript。这个特性可以提高网站性能，它的实现借助于 manifest 文件，如下：</p>
<pre><code class="lang-html">&lt;!doctype html&gt;
&lt;html manifest=”example.appcache”&gt;
…..
&lt;/html&gt;
</code></pre>
<p>与传统浏览器缓存相比，它不强制用户访问的网站内容被缓存。</p>
</blockquote>
<h4 id="-html-">浏览器加载和渲染html的顺序</h4>
<ul>
<li><p>1 IE下载的<strong>顺序是从上到下</strong>，渲染的顺序也是从上到下，下载和渲染是同时进行的。 </p>
</li>
<li><p>2 在渲染到页面的某一部分时，其上面的所有部分都已经下载完成（并不是说所有相关联的元素都已经下载完）。 </p>
</li>
<li><p>3 如果遇到语义解释性的标签嵌入文件（JS脚本，CSS样式），那么此时IE的下载过程会启用单独连接进行下载。 </p>
</li>
<li><p>4 样式表在下载完成后，将和以前下载的所有样式表一起进行解析，解析完成后，将对此前所有元素（含以前已经渲染的）重新进行渲染。 </p>
</li>
<li><p>5  JS、CSS中如有重定义，后定义函数将覆盖前定义函数。 </p>
</li>
<li><p>JS的加载 </p>
<ul>
<li><p>1 <strong>不能并行下载和解析</strong>（阻塞下载）。 </p>
</li>
<li><p>2 当引用了JS的时候，浏览器发送1个js request就会一直等待该request的返回。因为浏览器需要1个稳定的DOM树结构，而JS中很有可能有代码直接改变了DOM树结构，比如使用 document.write 或appendChild,甚至是直接使用的location.href进行跳转，浏览器为了防止出现JS修改DOM树，需要重新构建DOM树的情况，所以 就会阻塞其他的下载和呈现. </p>
</li>
</ul>
</li>
</ul>
<h3 id="2-html-">2 HTML基础知识内容</h3>
<h4 id="sgml-">SGML的了解</h4>
<h4 id="-">无序标签</h4>
<ul>
<li>dl  dt  dd ;</li>
<li>ul  li ;</li>
<li>ol li  </li>
</ul>
<h4 id="-void-">行内元素有哪些？块级元素有哪些？空（void）元素有哪些？</h4>
<blockquote>
<p>声明：CSS规范规定，每个元素都有<strong>display</strong>属性，确定该元素的类型，每个元素都有默认的display值，如div的display默认值为“block”，则为“块级”元素；span默认display属性值为“inline”，是“行内”元素。</p>
<ul>
<li>（1）行内元素有：<ul>
<li>a b span img input select strong（强调的语气）</li>
</ul>
</li>
<li>（2）块级元素有：
  +div ul ol li dl dt dd h1 h2 h3 h4…p</li>
<li>（3）常见的空元素：<ul>
<li>br hr img input link meta</li>
</ul>
</li>
<li>（4）鲜为人知的空元素：<ul>
<li>area base col command embed keygen param source track wbr</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="-">一些常用不常用的标签整理</h4>
<ul>
<li>strong:加粗</li>
<li>ins:下划线    </li>
<li>em:倾斜    </li>
<li>del:删除线</li>
<li>sub标签可以定义下标文本<blockquote>
<p> 包含在 <sub> 标签和其结束标签 </sub> 中的内容将会以当前文本流中字符高度的一半来显示，但是与当前文本流中文字的字体和字号都是一样的。</p>
</blockquote>
</li>
<li>i:通常用于放一些logo或者其他的小背景图    </li>
</ul>
<h4 id="label-">Label的作用是什么？如何使用？</h4>
<blockquote>
<p>label标签来定义表单控制间的关系，当用户选择该标签时，浏览器会自动将焦点转到和标签相关的表单控件上。</p>
<pre><code class="lang-html">&lt;label for=&quot;Name&quot;&gt;Number:&lt;/label&gt;
&lt;input type=&quot;text&quot; name=&quot;Name&quot; id=&quot;Name&quot; /&gt;
&lt;label&gt;Date:&lt;input type=&quot;text&quot; name=&quot;B&quot; /&gt;&lt;/label&gt;
</code></pre>
</blockquote>
<h4 id="-a-">运用a链接创建锚点</h4>
<blockquote>
<p>锚点是文档中某行的一个记号，类似于书签，用于链接到文档中的某个位置。当定义锚点后，我们可以创建直接跳至该锚点（比如页面中某个小节）的链接，这样使用者就无需不停地滚动页面来寻找他们需要的信息了。</p>
<ul>
<li>在使用a元素创建锚点时，需要使用name属性为其命名，代码如下所示：<pre><code class="lang-html">&lt;a name=”anchorname1”&gt;锚点一&lt;/a&gt;
&lt;!-- 然后就可以创建链接，直接跳转到锚点，代码如下所示： --&gt;
&lt;a href=”#anchorname1”&gt;回到锚点一&lt;/a&gt;
</code></pre>
</li>
<li>简单用a链接实现跳转到顶部的效果<pre><code class="lang-html">&lt;a href=&quot;#top&quot;&gt;
</code></pre>
</li>
</ul>
</blockquote>
<h2 id="-css">关于CSS</h2>
<h3 id="1-css-">1 CSS相关属性整理</h3>
<h4 id="1-0-">1.0 关于处理文本段落的属性</h4>
<ul>
<li><p>1.0 white-space:属性设置如何处理元素内的空白</p>
<ul>
<li>normal 默认。空白会被浏览器忽略。 </li>
<li>pre 空白会被浏览器保留。其行为方式类似 HTML 中的 pre 标签。 </li>
<li><strong>nowrap 文本不会换行</strong>(强制不换行效果)，文本会在在同一行上继续，直到遇到 br 标签为止。 </li>
<li>pre-wrap 保留空白符序列，但是正常地进行换行。 </li>
<li>pre-line 合并空白符序列，但是保留换行符。 </li>
<li>inherit 规定应该从父元素继承 white-space 属性的值。</li>
</ul>
</li>
<li><p>2.0 word-wrap:属性用来标明是否允许浏览器在单词内进行断句</p>
<ul>
<li>normal: 只在允许的断字点换行(浏览器保持默认处理) </li>
<li>break-word:在长单词或URL地址内部进行换行 </li>
</ul>
</li>
<li><p>3.0 word-break:属性用来标明怎么样进行单词内的断句。   </p>
<ul>
<li>normal：使用浏览器默认的换行规则。 </li>
<li>break-all:允许再单词内换行 </li>
<li>keep-all:只能在半角空格或连字符处换行 </li>
</ul>
</li>
<li><p><strong>超出显示省略号效果</strong></p>
<pre><code class="lang-css">p{text-overflow:ellipsis;//文本溢出显示省略号;
 overflow:hidden;
 white-space:nowrap;//强制不换行;
 }
</code></pre>
</li>
</ul>
<h4 id="2-0-">2.0 清除浮动的几种方式</h4>
<ul>
<li>第一种：在浮动元素的末尾加上空的标签例如<code>&lt;div style=”clear:both”&gt;&lt;/div&gt;</code>  <ul>
<li>缺点分析:会造成很多无意义的空标签，违反结构与样式分离的原则</li>
</ul>
</li>
<li>第二种：br标签和其自身的html属性,如<code>&lt;br clear=&quot;all&quot;&gt;</code><ul>
<li>缺点分析:违反结构与样式分离的原则</li>
</ul>
</li>
<li>第三种: 父元素设置<code>overflow:hidden</code>(在IE6中还需要触发haslayout，例如<code>zoom:1</code>);<ul>
<li>优点：不存在语义与结构化问题</li>
<li>缺点分析:内容增多的不会换行而是被影藏掉</li>
</ul>
</li>
<li>第四种: 父元素设置<code>overflow:auto</code>(无需加上<code>zoom:1</code>);<ul>
<li>缺点分析:多个嵌套后，firefox某些情况造成内容全选</li>
</ul>
</li>
<li>第五种: 父元素也设置浮动;<ul>
<li>缺点分析:会造成与父元素相邻的元素布局混乱</li>
</ul>
</li>
<li>第六种: 父元素设置<code>display:table</code>;<ul>
<li>缺点分析:虽然语义化明确,但是会改变盒模型属性</li>
</ul>
</li>
<li>第七种: 使用after伪元素的方式 (由于IE6-7不支持,需要设置zoom:1来触发hasLayout);<pre><code class="lang-css">  .clearfix:after { 
      content: &quot;.&quot;; 
      display: block; 
      height: 0; 
      clear: both; 
      visibility: hidden; 
  }
</code></pre>
</li>
</ul>
<h4 id="3-0-bfc-block-formatting-contexts-">3.0 重要概念之BFC(Block Formatting contexts)</h4>
<blockquote>
<p>概念：对css有了解的朋友肯定都知道盒式模型这个概念，对一个元素设置css，首先需要知道这个元素是block还是inline类型。而BFC就是用来格式化块级盒子，同样管理inline类型的盒子还有IFC，以及其他的FC。那首先我们就来看看FC的概念。</p>
<ul>
<li>Formatting Context：指页面中一个渲染区域，并且拥有一套渲染规则，他决定了其子元素如何定位，以及与其他元素的相互关系和作用。</li>
</ul>
</blockquote>
<ul>
<li><p>BFC：块级格式化上下文，它是指一个独立的块级渲染区域，只有Block-level Box参与，该区域拥有一套渲染规则来约束块级盒子的布局，且与区域外部无关。</p>
</li>
<li><p>触发条件：(满足下列条件之一就可以触发)</p>
<ul>
<li><p>1 根元素，即HTML元素</p>
</li>
<li><p>2 float的值不为none</p>
</li>
<li><p>3 overflow的值不为visible</p>
</li>
<li><p>4 display的值为inline-block、table-cell、table-caption</p>
</li>
<li><p>5 position的值为absolute或fixed</p>
</li>
</ul>
</li>
<li><p>作用一：可以阻止元素被浮动元素浮动</p>
<ul>
<li>&lt;说明&gt;与浮动元素响铃的已生成BFC的元素不能与浮动元素相互重覆盖</li>
<li>以此可以达到两列布局以及多列布局的一种方式:<pre><code class="lang-css">.left{
  float:left;
  width:180px;
}
.center{
  overflow:hidden;
  height:116px;        
}
.right{
  width:180px;
  float:right;
}
</code></pre>
<blockquote>
<p>通过以上的设置,由于中间的盒子在BFC中，不会与浮动的盒子重叠,就可以达到宽度自适应的效果。在<strong>两列布局的时候也很常用</strong></p>
</blockquote>
</li>
</ul>
</li>
<li><p>作用二：可以包含浮动元素，即解决<strong>高度塌陷</strong></p>
<ul>
<li>使得父元素包含子元素，常见的方式是为父元素设置overflow：hidden或者浮动父元素。根本原因在于创建BFC的元素，子浮动元素也会参与其高度计算，即不会产生高度塌陷问题。</li>
</ul>
</li>
<li><p>作用三：防止margin重叠:</p>
<ul>
<li>方式：只要将两个元素不放入同一个BFC中即可</li>
</ul>
</li>
</ul>
<h4 id="4-0-text-align">4.0 text-align</h4>
<ul>
<li>设置文本或者元素水平位置<ul>
<li>只对<strong>行内块元素/行内元素水平位置</strong>有用，对块状元素不起作用。(input是行内元素)</li>
</ul>
</li>
</ul>
<h4 id="5-0-margin-">5.0 margin的应用</h4>
<ul>
<li><code>margin：0 auto</code> 可以让拥有宽度的元素根据父元素的宽度水平居中</li>
<li><code>margin-left:auto</code> 让左边距填满,即元素会被挤到父元素的最右边   </li>
<li>使用<strong>margin:auto</strong>实现居中,(并不常用),代码如下:<pre><code class="lang-css">  .container{
       width: 300px;
       height: 300px;
       position:relative;
       background: green;
    }
    .son{
        width: 100px; 
        height: 100px;
        background: red;
        position:absolute;
        left: 0; top: 0; right: 0; bottom: 0;//必须都设置为0;
        margin-right:auto;
    }
</code></pre>
<h4 id="6-0-">6.0 实现元素在父盒子中居中的几种方式整理:</h4>
</li>
<li>在盒子内居中<ul>
<li>方式一：<code>top:50%;left:50%;margin-top:-自身高一半;margin-left:- 自身宽度一半</code>;</li>
<li>方式二: 使用<code>transfrom:translate(-50%,-50%)</code>;</li>
<li>方式三: <code>display: flex;justify-content: center;align-items: center;</code></li>
<li>方式四: 父盒子<code>position:relative</code>,子盒子<code>position:absolute</code>,然后同时设置left,right,top,bottm都为0,最后设置<code>margin:auto</code>;</li>
<li>方式五: 最不好的方法：使用maigin 或 定位 去拼凑数据</li>
</ul>
</li>
</ul>
<h4 id="7-0-css-">7.0 CSS三角的写法</h4>
<pre><code class="lang-css">    div {
        width: 0;     
        height: 0;
        margin: 100px auto;
        border-width: 10px;    /* 数值控制三角大小 */
        border-style: solid dashed dashed dashed;  /* dashed 是为了照顾ie6 灰色底的问题 */
        border-color: #f00 transparent transparent transparent;   /* 上 右  下 左 模式 */
         /* transparent透明  背景颜色默认也是透明的 */
        overflow: hidden;  /* ie6 高度问题 */
    }
</code></pre>
<h4 id="8-0-css-">8.0 实现局部滚动条滚动的CSS方式</h4>
<pre><code class="lang-html">&lt;style&gt;
    ::-webkit-scrollbar {
        width: 4px;
    }
    ::-webkit-scrollbar-track {
        -webkit-box-shadow: inset 0 0 6px rgba(255,255,211,0);
        border-radius: 10px;
    }
    ::-webkit-scrollbar-thumb {
        border-radius: 10px;
        background: rgba(0,0,0,0);
        -webkit-box-shadow: inset 0 0 6px rgba(255,125,232,0);
    }
    li{
        width: 100%;
        height: 40px;
        line-height: 40px;
        list-style: none;
        text-align: center;
        border: 1px solid #4DD7C0;
    }
    *{
        margin: 0;
        padding: 0;
    }
&lt;/style&gt;
&lt;body&gt;
&lt;div style=&quot;width:200px; height: 400px; overflow: hidden;w-x:hidden; overflow-y: scroll; background:blue;-webkit-overflow-scrolling: touch;&quot;&gt;
    &lt;div style=&quot;width:100%;&quot;&gt;
        &lt;li&gt;&lt;a href=&quot;#&quot;&gt;列表&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;列表&lt;/li&gt;
        &lt;li&gt;列表&lt;/li&gt;
        &lt;li&gt;列表&lt;/li&gt;
        &lt;li&gt;列表&lt;/li&gt;
        &lt;li&gt;列表&lt;/li&gt;
        &lt;li&gt;列表&lt;/li&gt;
        &lt;li&gt;列表&lt;/li&gt;
        &lt;li&gt;列表&lt;/li&gt;
        &lt;li&gt;列表&lt;/li&gt;
        &lt;li&gt;列表&lt;/li&gt;
        &lt;li&gt;列表&lt;/li&gt;
    &lt;/div&gt;
&lt;/div&gt;
&lt;/body&gt;
</code></pre>
<h4 id="9-0-">9.0 关于继承、</h4>
<ul>
<li>宽度、行高、颜色可以继承，高度不可以继承</li>
</ul>
<h4 id="10-0-padding-">10.0 padding撑盒子的问题</h4>
<ul>
<li>div不加上宽度,加padding不会撑开盒子</li>
<li>如果加上宽度，加padding会撑开盒子</li>
</ul>
<h4 id="11-0-">11.0 字间距</h4>
<ul>
<li>text-indent:用于设置缩进</li>
<li>letter-spacing:用于设置字间距 </li>
<li>word-spaing:用于设置单词间的间距(对中文无效)</li>
</ul>
<h4 id="12-0-css-">12.0 讲述下css盒模型</h4>
<ul>
<li>1）盒模型： 内容(content)、填充(padding)、边界(margin)、 边框(border)</li>
<li>2）有两种， IE 盒子模型、标准 W3C 盒子模型；IE的content部分包含了 border 和 padding;</li>
</ul>
<h4 id="background-repeat-">background-repeat新增的两个值</h4>
<ul>
<li><p><em>space</em>:向两端对齐平铺,多余留白</p>
</li>
<li><p><em>round</em>:向两端对齐平铺,<strong>多余直接拉伸</strong></p>
</li>
</ul>
<h2 id="js-">Js基础知识</h2>
<h3 id="js-">Js中基本方法整理</h3>
<h4 id="1-0-">1.0 添加删除数组</h4>
<ul>
<li>arr.push(5,6,7)    从后面添加元素 返回新数组的长度(可以直接改变旧数组)</li>
<li>arr.pop()          从后面删除元素 返回被删除的元素</li>
<li>arr.shift()        从前面删除元素 返回被删除的元素</li>
<li>arr.unshift(0,1)   从前面添加元素 返回新数组的长度</li>
<li>arr.reverse()   反转数组,改变原来数组 </li>
</ul>
<h4 id="2-0-">2.0 截取数组中元素</h4>
<ul>
<li>arr.slice(0, 2)         <ul>
<li>1开始 2结束<strong>[start,end)</strong>开始能取到 结束取不到 不会改变原数组</li>
</ul>
</li>
<li>arr.splice(0, 2,&quot;a&quot;)    <ul>
<li>1开始的位置 2删除的个数 3要加入的元素(可以不添加),<strong>会对原数组进行修改</strong>,删除元素，并向数组添加新元素。 </li>
</ul>
</li>
</ul>

          	</article>
        </div>
		</div>
  </body>
</html>
<script type="text/javascript" src="toc/js/jquery-1.4.4.min.js"></script>
<script type="text/javascript" src="toc/js/jquery.ztree.all-3.5.min.js"></script>
<script type="text/javascript" src="toc/js/ztree_toc.js"></script>
<script type="text/javascript" src="toc_conf.js"></script>

<SCRIPT type="text/javascript" >
<!--
$(document).ready(function(){
    var css_conf = eval(markdown_panel_style);
    $('#readme').css(css_conf)
    
    var conf = eval(jquery_ztree_toc_opts);
		$('#tree').ztree_toc(conf);
});
//-->
</SCRIPT>