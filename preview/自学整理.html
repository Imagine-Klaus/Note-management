<html>
  <head>
	  <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>i5ting_ztree_toc:自学整理</title>
		<link href="toc/style/github-bf51422f4bb36427d391e4b75a1daa083c2d840e.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/style/github2-d731afd4f624c99a4b19ad69f3083cd6d02b81d5.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/zTreeStyle/zTreeStyle.css" media="all" rel="stylesheet" type="text/css"/>
	  <style>
		pre {
		    counter-reset: line-numbering;
		    border: solid 1px #d9d9d9;
		    border-radius: 0;
		    background: #fff;
		    padding: 0;
		    line-height: 23px;
		    margin-bottom: 30px;
		    white-space: pre;
		    overflow-x: auto;
		    word-break: inherit;
		    word-wrap: inherit;
		}

		pre a::before {
		  content: counter(line-numbering);
		  counter-increment: line-numbering;
		  padding-right: 1em; /* space after numbers */
		  width: 25px;
		  text-align: right;
		  opacity: 0.7;
		  display: inline-block;
		  color: #aaa;
		  background: #eee;
		  margin-right: 16px;
		  padding: 2px 10px;
		  font-size: 13px;
		  -webkit-touch-callout: none;
		  -webkit-user-select: none;
		  -khtml-user-select: none;
		  -moz-user-select: none;
		  -ms-user-select: none;
		  user-select: none;
		}

		pre a:first-of-type::before {
		  padding-top: 10px;
		}

		pre a:last-of-type::before {
		  padding-bottom: 10px;
		}

		pre a:only-of-type::before {
		  padding: 10px;
		}

		.highlight { background-color: #ffffcc } /* RIGHT */
		</style>
  </head>
  <body>
	  <div>
				<div style='width:25%;'>
						<ul id="tree" class="ztree" style='width:100%'>

						</ul>
				</div>
        <div id='readme' style='width:70%;margin-left:20%;'>
          	<article class='markdown-body'>
            	<p>[TOC]</p>
<h1 id="-">平时所研究的问题</h1>
<h2 id="location-href-">location.href 进行跳转</h2>
<ul>
<li><code>location.href=&quot;url&quot;</code>可以用于本页面的跳转</li>
</ul>
<h2 id="ajax-serialize-">ajax中 serialize()提交表单数据</h2>
<ul>
<li>jQuery ajax的serialize() 方法表单序列化为键值对（key1=value1&amp;key2=value2…）<pre><code class="lang-html">  $.ajax({
      type: &#39;post&#39;,
      url: &#39;your url&#39;,
      data: $(&quot;form&quot;).serialize(), 
      success: function(data) {
          // your code
      }
  });
</code></pre>
</li>
</ul>
<h2 id="reponsed-js-ie6-8-">reponsed.js解决IE6~8的响应式布局问题</h2>
<ul>
<li>媒体查询的支持程度是IE9+以及其他现代的浏览器</li>
<li><p>!--[if lt IE 9]&gt;<script src = "http://cdn.bootcss.com/respond.js/1.4.2/respond.min.js"></script>&lt;![endif]--&gt; </p>
</li>
<li><p>基本的布局书写样式</p>
</li>
</ul>
<pre><code class="lang-css">html,body {
    height: 100%;
}
@media only screen and (min-width: 480px){
    body {
        background: yellow;
    }
}
@media only screen and (min-width: 640px) and (max-width: 1024px) {
    body {
        background: green;
    }
}
@media screen and (min-width: 1024px){
    body {
        background: blue;
    }
}
</code></pre>
<h2 id="-">关于立即执行函数表达式</h2>
<h3 id="-">保存闭包的状态</h3>
<ul>
<li>一个立即调用的函数表达式可以用来锁定值并且有效的保存此时的状态，因为任何定义在一个函数内的函数都可以使用外面函数传递进来的参数和变量(这种关系被叫做闭包)。</li>
</ul>
<h2 id="-">避免全局污染的一些措施</h2>
<ul>
<li>尽量少用全局对象</li>
<li>使用模块模式</li>
</ul>
<h2 id="cookie-">cookie到底是什么</h2>
<ul>
<li>cookie和session用于跟踪用户的整个会话,cookie通过在客户端记录信息确定用户身份,而session是在服务端记录信息确定用户身份的。</li>
<li><p><em>一个用户的所有请求都同属于一个会话</em>,由于HTTP是无状态协议,一旦数据交换完毕,客户端与服务器端的连接就会断开,<em>如果再次请求数据会建立新的连接</em> <strong>cookie就是跟踪这种会话的机制</strong></p>
</li>
<li><p>举个QQ空间的例子:
当我们登录QQ空间的时候，可以选择保存用户名和密码，这样下次登录的时候浏览器可以自动填充或者自动登陆，此时使用的是cookie技术，</p>
<pre><code class="lang-html">  将于http://qzone.qq.com/
</code></pre>
<p>域名对应的cookie保存到硬盘中，下次访问的时候浏览器查找保存在硬盘中的与该域名对应的cookie填充。
②登录之后，我们可能做些操作，比如删除日志，发表说说，
这些只有登录用户才能做的事情可以使用cookie也可以使用session进行会话跟踪</p>
</li>
<li><p><strong>一般用cookie存储</strong></p>
</li>
</ul>
<h3 id="cookie-">cookie具有的属性</h3>
<ul>
<li>cookie具有<strong>不可跨域名性</strong>,不同域名下的cookie不可相互影响,例Google只能操作google的cookie</li>
</ul>
<h3 id="cookie-">cookie的存储格式</h3>
<ul>
<li>正如上面所说，Cookie的存取方式有点类似于哈希表，是以名称作为索引存取的。一个Cookie的格式如下：<ul>
<li>Cookie名称（作为Cookie的索引便于以后的各种操作）+“=”+Cookie值+“；expires=+有效期+“；path=”+路径+“；domain=”+域+“；secure=”+安全级别</li>
</ul>
</li>
</ul>
<h3 id="cookie-">Cookie 的属性选项</h3>
<h4>expires / max-age</h4>
<code>expires/max-age</code>都是控制cookie的有效期的,如果没有设置的话那么关闭浏览器就没有了

- <h5>expires</h5>
&gt; <code>expires</code>选项用来设置Cookie的有效期<br>
方式:必须是GMT时间格式的(可以通过<code>new Data().toGMTString()</code>或者new Data().toUTCString()获得)

<code>javascript
    .get(&#39;/&#39;, (req, res) =&gt; {
  // 这个 Cookie 设置十秒后失效
  res.cookie(&#39;testName0&#39;, &#39;testValue0&#39;, {
    expires: new Date(Date.now() + 10000)
  })
  // 这个 Cookie 不设置失效时间
  res.cookie(&#39;testName1&#39;, &#39;testValue1&#39;)
  res.send(&#39;&lt;h1&gt;hello world!&lt;/h1&gt;&#39;)
})</code>

- <h5>max-age</h5>

&gt; <code>expires</code> 是 http/1.0 协议中的选项，在新的 http/1.1 协议中 expires 已经由 <code>max-age</code> 选项代替，两者的作用都是限制 Cookie 的有效时间。expires 的值是一个时间点 (<strong>Cookie 失效时刻 = expires</strong>，而 max-age 的值是一个以秒为单位时间段 (<strong>Cookie 失效时刻 = 创建时刻 + max-age</strong>)

<code>javascript
app.get(&#39;/&#39;, (req, res) =&gt; {
  res.cookie(&#39;testName0&#39;, &#39;testValue0&#39;, {
    // express 这个参数是以毫秒来做单位的
    // 实际发送给浏览器就会转换为秒
    // 十秒后失效
    maxAge: 10000
  })
  res.cookie(&#39;testName1&#39;, &#39;testValue1&#39;)
  res.send(&#39;&lt;h1&gt;hello world!&lt;/h1&gt;&#39;)
})</code>
----------------

<h4>domain 和 path</h4>

<blockquote>
<p>name、domain 和 path 可以标识一个唯一的 Cookie。domain 和 path 两个选项共同决定了 Cookie 何时被浏览器自动添加到请求头部中发送出去。具体是什么原理请看 Cookie 的作用域和作用路径 这个章节。
如果没有设置这两个选项，则会使用默认值。domain 的默认值为设置该 Cookie 的网页所在的域名，path 默认值为设置该 Cookie 的网页所在的目录。</p>
</blockquote>
<p><h4>secure</h4></p>
<blockquote>
<p><code>secure</code>选项用来设置 Cookie 只在确保安全的请求中才会发送。当请求是 HTTPS 或者其他安全协议时，包含 secure 选项的 Cookie 才能被保存到浏览器或者发送至服务器。 
<strong>不过默认情况下为空</strong>,所以不管怎样都会被发出去</p>
</blockquote>
<p><h4>httpOnly</h4></p>
<blockquote>
<p>默认情况下为空,用来设置Cookie是否能通过js去访问 ,如果设置为<code>true</code>的话,则不能够用js去访问Cookie</p>
</blockquote>
<h3 id="-cookie">客户端版设置cookie</h3>
<pre><code class="lang-javascript">1. 设置从Cookie
document.cookie =&quot;name=value&quot;
//可以设置Cookie下列选项 :expires /domian /path / 
document.cookie=&#39;name=value; expires=Thu, 26 Feb 2116 11:50:25 GMT; domain=sankuai.com; path=/&#39;;

2. secure
//只有在https协议下才能生效

3. Cookie的属性都是唯一标识一个cookie的  只要覆盖掉原来的 设置max-age= 0就可以了

let removeCookie = (name, path, domain) =&gt; {
  document.cookie = `${name}=; path=${path}; domain=${domain}; max-age=0`
}
</code></pre>
<h2 id="-jwt">了解JWT</h2>
<blockquote>
<p>JWT声明一般被用来在身份提供者和服务器提供者间传递被认证的用户的信息,以便于从服务器获取资源</p>
</blockquote>
<h3 id="-session-">传统的session认证</h3>
<p>http协议是一种无状态的协议,这就意味着当我们的用户向我们提供了用户信息进行验证了之后,下一次用户还需要认证一次,根据HTTP协议,我们并不能判断是哪个用户发出的请求,那么我们就需要<strong>在服务器端保存一下用户的信息</strong>,这份信息会在响应时<strong>传递给浏览器</strong>,告诉他<strong>保存为cookie</strong>,下次加载的时候通过存储的cookie与服务器中session进行比对,然后识别用户信息,  <em>但是扩展性不强,服务器不能承载更多的用户</em></p>
<h4 id="-">存在的问题</h4>
<pre><code class="lang-html"> 1.服务器压力:用户信息通常是存储在服务器的内存中
 2.扩展性:保存在服务器内存中以为着用户的请求还必须是在指定的服务器上请求,限制了负载均衡
 3.安全性CSRF:session基于cookie 如果cookie被截获 黑客就可能伪造一份cookie进行攻击
</code></pre>
<h3 id="-token-">基于token的鉴权机制</h3>
<p>介绍下流程:</p>
<ul>
<li>用户使用用户名和密码提交到服务器</li>
<li>服务器进行验证用户的信息</li>
<li>服务器通过验证给用户发送一个token</li>
<li>客户端存储token,并在每次请求中发送token</li>
<li>服务器验证token,并返回数据</li>
</ul>

          	</article>
        </div>
		</div>
  </body>
</html>
<script type="text/javascript" src="toc/js/jquery-1.4.4.min.js"></script>
<script type="text/javascript" src="toc/js/jquery.ztree.all-3.5.min.js"></script>
<script type="text/javascript" src="toc/js/ztree_toc.js"></script>
<script type="text/javascript" src="toc_conf.js"></script>

<SCRIPT type="text/javascript" >
<!--
$(document).ready(function(){
    var css_conf = eval(markdown_panel_style);
    $('#readme').css(css_conf)
    
    var conf = eval(jquery_ztree_toc_opts);
		$('#tree').ztree_toc(conf);
});
//-->
</SCRIPT>