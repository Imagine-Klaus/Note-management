<html>
  <head>
	  <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>i5ting_ztree_toc:面向对象笔记</title>
		<link href="toc/style/github-bf51422f4bb36427d391e4b75a1daa083c2d840e.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/style/github2-d731afd4f624c99a4b19ad69f3083cd6d02b81d5.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/zTreeStyle/zTreeStyle.css" media="all" rel="stylesheet" type="text/css"/>
	  <style>
		pre {
		    counter-reset: line-numbering;
		    border: solid 1px #d9d9d9;
		    border-radius: 0;
		    background: #fff;
		    padding: 0;
		    line-height: 23px;
		    margin-bottom: 30px;
		    white-space: pre;
		    overflow-x: auto;
		    word-break: inherit;
		    word-wrap: inherit;
		}

		pre a::before {
		  content: counter(line-numbering);
		  counter-increment: line-numbering;
		  padding-right: 1em; /* space after numbers */
		  width: 25px;
		  text-align: right;
		  opacity: 0.7;
		  display: inline-block;
		  color: #aaa;
		  background: #eee;
		  margin-right: 16px;
		  padding: 2px 10px;
		  font-size: 13px;
		  -webkit-touch-callout: none;
		  -webkit-user-select: none;
		  -khtml-user-select: none;
		  -moz-user-select: none;
		  -ms-user-select: none;
		  user-select: none;
		}

		pre a:first-of-type::before {
		  padding-top: 10px;
		}

		pre a:last-of-type::before {
		  padding-bottom: 10px;
		}

		pre a:only-of-type::before {
		  padding: 10px;
		}

		.highlight { background-color: #ffffcc } /* RIGHT */
		</style>
  </head>
  <body>
	  <div>
				<div style='width:25%;'>
						<ul id="tree" class="ztree" style='width:100%'>

						</ul>
				</div>
        <div id='readme' style='width:70%;margin-left:20%;'>
          	<article class='markdown-body'>
            	<h3 id="-">面向对象笔记</h3>
<h3 id="-">面向对象的特性</h3>
<ul>
<li>抽象性</li>
<li>继承性</li>
<li>封装性</li>
<li>多态性</li>
</ul>
<h3 id="js-">JS是基于对象的多范式的编程语言</h3>
<ul>
<li>是基于对象的多范式的编程语言</li>
</ul>
<h3 id="-in-">原型与in操作符</h3>
<p>in操作符会在通过对象能够访问到给定属性是返回true,无论该属性存在于实例中还是原型中。
通过&quot;in&quot;操作符和hasOwnProperty想结合的方式可以判断属性存在于实例中还是原型中  例：</p>
<pre><code class="lang-javascript">console.log(&quot;name&quot; in person1);
 &lt;!--person1是通过构造函数创建的实例对象--&gt;

  console.log(person1.hasOwnProperty(&quot;name&quot;))
</code></pre>
<p>检测存在于对象中，还是原型中。</p>
<pre><code>  function hasPrototypeProperty(object,name){
      return  !object.hasOwnProperty(name) &amp;&amp; (name in object)
                }
</code></pre><h3 id="-">基本类型，值类型的区别。</h3>
<p>   基本类型：(只需要开辟一段内存储数据即可)直接存储，数据存储在栈中。</p>
<p> 值类型:存储的是对象的引用，存储于堆中。实际上需要两块内存空间，一个存储数据，一个存储变量以引用对象。</p>
<h3 id="-">属性的可枚举性定义：</h3>
<pre><code>var obj = {name:&quot;张三&quot;,age:18}
for(var key in obj){
console.log(&quot;key:&quot; + key + &quot;，value:&quot; + obj[key]);
}
</code></pre><blockquote>
<p>输出:key:name，value:张三和key:age，value:18--&gt;
  这里的可枚举性就是说for-in的这种写法可以得到这个对象的属性名</p>
</blockquote>
<pre><code>var obj1 = {};
Object.defineProperties(obj1, {
name: {
value: &quot;张三&quot;,
enumerable: false
      },
age: {
value: 18,
enumerable: false
     }
});

for(var key in obj1){
console.log(&quot;key:&quot; + key + &quot;，value:&quot; + obj[key]);
}
</code></pre><p>这里不会输出任何东西，但是可以用obj1.name和obj1.age直接取值。
    当然obj1[&quot;name&quot;]也是可以得到张三的。
    但是不能用for来枚举出他有什么属性。</p>
<h3 id="-">更简单的原型语法:</h3>
<p>总是使用Person.prototype的方式设置较为繁琐.更常见的做法是用一个包含所有属性和方法的对象字面量来重写整个原型对象：</p>
<pre><code class="lang-javascript">function Person(){};
     Person.prototype={
        name:&quot;张三&quot;，
        age:&quot;19&quot;,
        gender:&quot;男&quot;
     }
</code></pre>
<p>通过这样的方式会改写Person的prototype属性constructor的指向(将会指向Object),如果在对象那个字面量中写入<strong>constructor:Person</strong>将会改回到原来的状态，但是constructor就会变成可枚举的状态;</p>
<p>所以可以在末尾通过-<strong>Object.defineProperty()</strong>来修改，如下:</p>
<pre><code> Object.defineProperty(Person.prototype,&quot;constructor&quot;,{
                                                          enumerable:true,
                                                          value:Person    });
</code></pre><h3 id="-">原型的动态性</h3>
<p>  如果先创建一个对象实例:<strong>var friend = new Person();</strong></p>
<p>  然后重写原型对象：<strong>Person.prototype={...}</strong>;</p>
<p>  在通过实例对象调用重写的原型对象后是调用不到的：<strong>friend.sayName()</strong>; //会显示错误</p>
<p><strong>Reason:</strong>
       调用构造函数创建一个实例对象时会为实例对象添加一个指向最初原型的指针，而重写原型会切断实例对象与原型之间的联系</p>
<p>   在重写一个原型对象后,其<strong>constructor</strong>指向的是<strong>Person</strong>,<strong>Person</strong>的<strong>Prototype</strong>指向重写的对象原型。
   而friend的实例对象的Prototype指向的还是原本的对象原型。</p>
<h3 id="-">原型对象的问题：</h3>
<pre><code class="lang-javascript">function Person(){}
          Person.prototype={
            constructor:Person,
            name:&quot;张三&quot;,
            friend:[&#39;你&#39;,&#39;我&#39;]
          }
                var person1 = new Person();
                var person2 = new Person();
            person1.friend.push(&quot;小明&quot;);
            console.log(person1.friend);&lt;!--结果[&#39;你&#39;,&#39;我&#39;,&#39;小明&#39;]--&gt;
            console.log(person2.friend);&lt;!--结果[&#39;你&#39;,&#39;我&#39;,&#39;小明&#39;]--&gt;
</code></pre>
<hr>
<p>由上面的实例可以知道，在<strong>person1</strong>这个实例对<strong>friend</strong>引用的数组进行了修改之后,由于这个数组存在于<strong>Person.prototype</strong>中而不是在<strong>friends</strong>中,所以做的修改同样会 在<strong>person2.friend</strong>中反映出来</p>
<p>如果在<strong>person1</strong>调用<strong>friend</strong>前对<strong>friend</strong>重定义 <strong>person1.friend=[&quot;李磊&quot;，&quot;德帅&quot;]</strong>的话，就不会对其他实例调用时产生影响。</p>
<h3 id="-">隐式原型</h3>
<p>   每个对象都有一个<em>proto</em>属性，指向创建该对象的函数的prototype；
   但是<strong>Object.prototype</strong>的<em>proto</em>指向的是null</p>
<h3 id="-">深拷贝和浅拷贝</h3>
<p>   <strong>浅拷贝</strong>：也就是拷贝了所需要拷贝的对象的地址和引用，任意拷贝后的复杂类型所指向的数据的改变都会改变原拷贝体的数据。</p>
<p>   <strong>深拷贝</strong>:在堆中重新分配内存，并且把源对象所有属性都进行新建拷贝，以保证深拷贝的对象的引用图不包含任何原有对象或对象图上的任何对象，拷贝后的对象与原来的对象是完全隔离，互不影响。
   常见方法：</p>
<pre><code>      &gt;JSON.parse(),
      JSON.stringify(),
      jQury的$.extend(true,{},obj)，
      lodash的_.cloneDeep和_.clone(value, true)。
</code></pre><h3 id="-">关于原型的理解图</h3>
<p><img src="./imgs/_proto_.png" alt="Alt text"></p>
<p>这是proto以及原型链的原理图，留以理解备用。</p>
<blockquote>
<p>每个函数都有一个<strong>prototype</strong> ，每个对象都有一个 <strong> prot  </strong> ，可以成为隐式原型,指向的是----&gt;创建该对象的函数的prototype。</p>
<p>所有函数的默认原型都是Object的实例，因此默认原型都会包含一个内部指针，指向Object.prototype。
但是Object.prototype的“ proto”指向的是null.</p>
</blockquote>
<h3 id="-">继承原型成为子类</h3>
<h4 id="-">子类型有时候需要重定义或者添加原型中的方法</h4>
<pre><code class="lang-javascript">function Supertype() {
    this.property = true;
}
Supertype.prototype.getSuperValue = function() {
    return this.property;
}

function Subtype() {
    this.subproperty = false;
}

/*继承派生成为子类(subclass),并且继承Supertype方法*/
Subtype.prototype = new Supertype();
Subtype.prototype.getSubValue = function() {
  return this.subproperty;
}
Subtype.prototype.getSuperValue = function() {
  return false;  //将原来的方法覆盖掉了
}
var instance = new Subtype();
console.log(instance.getSuperValue()) // --&gt;false;
console.log(instance.getSubValue())//--&gt;false；
</code></pre>
<blockquote>
<p>在通过 subtype的实例调用getsuperValue这个方法时,调用的是这个重新定义的方法
 但是在Supertype调用getsuperValue这个方法时,调用的还是原来的那个方法
 <strong>注：给原型添加方法的代码一定要在替换原型的语句之后。</strong></p>
</blockquote>
<p><strong>特别注意：在通过原型链实现继承时，不能使用对象字面量创建原型方法</strong></p>
<h3 id="-">实现继承的六种方式：</h3>
<blockquote>
<p>1.0原型链继承</p>
</blockquote>
<p>不多做介绍</p>
<blockquote>
<p>2.0借用构造函数
基本思想：在子类型构造函数的内部调用超类构造函数，通过使用call()和apply()方法可以在新创建的对象上执行构造函数。</p>
</blockquote>
<pre><code class="lang-javascript"> function Person() {
        this.extend = function () {
           console.log(&quot;我新来的别欺负我&quot;)
        }
        this.name = &quot;你知道&quot;
 }
 function Person2() {
        Person.call(this);
 }
    var instance = new Person()
    var o1 = new Person2();
    o1.extend();
</code></pre>
<blockquote>
<p>3.0组合继承
基本思想：  </p>
</blockquote>
<p>繁琐，不给自己看了。</p>
<blockquote>
<p>4.0原型式继承
基本思想：借助原型可以基于已有的对象创建新对象，同时还不必须因此创建自定义的类型。</p>
</blockquote>
<p>以下是demo：</p>
<pre><code class="lang-javascript">var o  ={name:&quot;张三&quot;,age:10,gender:&quot;man&quot;}
var obj =Object.create(o)   
//但是有兼容性问题
</code></pre>
<p><strong>这是兼容函数：</strong></p>
<pre><code>function createWithObject(obj){
  if(Object.create){
    return Object.create();
  }else{
    function F(){};
    F.prototype=obj;
    return new F;
  }
}
</code></pre><hr>
<blockquote>
<p>5.寄生式继承
基本思想：创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后再像真正是它做了所有工作一样返回对象。</p>
</blockquote>
<hr>
<blockquote>
<p>6.寄生组合式继承
基本思想：通过借用函数来继承属性，通过原型链的混成形式来继承方法</p>
</blockquote>
<h3 id="apply-call-">apply与call用法：</h3>
<p>apply示例：</p>
<pre><code>    //定义一个人类
    function Person(name,age)
    {
        this.name=name;
        this.age=age;
    }
    /*定义一个学生类*/
    functionStudent(name,age,grade)
    {
        Person.apply(this,arguments);
        this.grade=grade;
    }
    //创建一个学生类
    var student=new Student(&quot;qian&quot;,21,&quot;一年级&quot;);
    //测试
    alert(&quot;name:&quot;+student.name+&quot;\n&quot;+&quot;age:&quot;+student.age+&quot;\n&quot;+&quot;grade:&quot;+student.grade);
    //大家可以看到测试结果name:qian  age:21  grade:一年级
    //学生类里面我没有给name和age属性赋值啊,为什么又存在这两个属性的值呢,这个就是apply的神奇之处.
</code></pre><p>call：
在Studen函数里面可以将apply中修改成如下:
<strong>Person.call(this,name,age);</strong></p>
<hr>
<p>1.0  什么情况下用apply,什么情况下用call</p>
<blockquote>
<p>在给对象参数的情况下,如果参数的形式是数组的时候,比如apply示例里面传递了参数arguments,这个参数是数组类型,并且在调用Person的时候参数的列表是对应一致的(也就是Person和Student的参数列表前两位是一致的) 就可以采用 apply , 如果我的Person的参数列表是这样的(age,name),而Student的参数列表是(name,age,grade),这样就可以用call来实现了,也就是直接指定参数列表对应值的位置(Person.call(this,age,name,grade));</p>
</blockquote>
<p>2.0 apply的一些其他巧妙用法</p>
<blockquote>
<p>apply能够将一个数组默认的转化为一个参数列表<strong>[param1,param2,param3]</strong> 转换为 <strong>param1,param2,param3</strong> </p>
</blockquote>
<p> a)     Math.max 可以实现得到数组中最大的一项:</p>
<blockquote>
<p>因为Math.max 参数里面不支持Math.max([param1,param2]) 也就是数组。</p>
<p>但是它支持<strong>Math.max(param1,param2,param3…)</strong>,所以可以根据刚才apply的那个特点来解决 <strong>var max=Math.max.apply(null,array)</strong>,这样轻易的可以得到一个数组中最大的一项(<strong>apply会将一个数组装换为一个参数接一个参数的传递给方法</strong>)</p>
<p><strong>同理得到最小项也可以用这个方法</strong>  </p>
</blockquote>
<p>b) Array.prototype.push 可以实现两个数组合并:</p>
<pre><code> vararr1=new Array(&quot;1&quot;,&quot;2&quot;,&quot;3&quot;);
 vararr2=new Array(&quot;4&quot;,&quot;5&quot;,&quot;6&quot;);
Array.prototype.push.apply(arr1,arr2);
console.log(arr1);--&gt;(6) [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;]
console.log(arr2);--&gt;(3) [&quot;4&quot;, &quot;5&quot;, &quot;6&quot;]
</code></pre><h3 id="callee-caller">callee与caller</h3>
<h4 id="callee-">callee:</h4>
<p><strong>语法：arguments.callee //当前函数的引用。</strong></p>
<pre><code>funciton foo(){
    console.log(arguments.callee==foo)
}
// 一般在函数内部，实现函数递归时候,

function fn(){
    argument.callee();//使用callee来递归
}
</code></pre><blockquote>
<p>使用callee递归的好处：无论调用函数是什么都可以执行。//在函数名被更改的情况下</p>
</blockquote>
<h4 id="caller-">caller:</h4>
<p><strong>:拜师调用函数</strong>：</p>
<pre><code>function f1(){
   f2();
}
f1()
//f1称为调用者,f2称为被调用者
</code></pre><blockquote>
<p>caller就是在被调用函数中，获得调用函数的引用。
<strong>语法：函数名.caller</strong>    </p>
</blockquote>
<pre><code>function f2(){
    console.log(f2.caller);--&gt;//将获取itcast()函数（其调用者）
}
function itcast() {
    f2();
   }
itcast();
</code></pre><h3 id="eval-">eval函数</h3>
<p><strong>功能：可以直接使用eval函数，来实现字符串代码，可以将字符串当代码执行</strong></p>
<pre><code>eval(&quot;var num=123;&quot;);
eval(&quot;console.log(num)//--&gt;123
// eval 是用来执行字符串表示的JS代码的，所以隐含的数据里面  {} 实际上是代码块的含义   
</code></pre><blockquote>
<p><strong>eval函数会在整个作用域范围起作用</strong>
,而在 Function()内部执行的字符串代码只在函数内部使用,并且需要调用</p>
</blockquote>
<h3 id="json-">JSON对象，以及格式的转换</h3>
<blockquote>
<p>JSON格式（严格的国际通用是数据表示协议，结构）</p>
</blockquote>
<pre><code>var data = [{&quot;name&quot;:&quot;张三&quot;，&quot;age&quot;:&quot;19&quot;},{&quot;name&quot;:&quot;李四&quot;}]
</code></pre><blockquote>
<p>JSON有两种结构：{ },  [ ]
将字符串转变成对象，有三种方法：</p>
</blockquote>
<ul>
<li><p>第一种
  var o1 = eval(&quot;(&quot;+data+&quot;)&quot;);//第一种
  //必须在外面套上圆括号
  //   </p>
</li>
<li><p>第二种</p>
<p>  var o2 =(new Function(&quot;return&quot;+data))();//第二种</p>
</li>
<li><p>第三种</p>
<p>  var o3 = JSON.parse(data)  这种用法对data的格式最为严格</p>
</li>
</ul>
<h3 id="instanceof">instanceof</h3>
<h4 id="instanceof-">instanceof语法</h4>
<blockquote>
<p>boolean 对象  instanceof 构造函数
判断构造函数的原型属性 是否在对象的原型链上</p>
</blockquote>
<pre><code>a is instanceof b  // a 是 b 构造出来的实例
</code></pre><h3 id="-">语句声明</h3>
<p>如果有多个var 名字是一样的，后面的var都会被忽略</p>
<h3 id="new">NEW</h3>
<p> new 要跟函数结合</p>
<h3 id="apply-">apply借用方法的案例</h3>
<p><strong>先演示下数组的合并方法</strong></p>
<pre><code>var arr1[1,2,3]
var arr2[5,6];
arr1.push(arr2[0],arr2[1]);
   //用apply方式能够更加简洁
arr1.push.apply(arr1,arr2);  
</code></pre><p>那么将页面中所有的DIV和P标签都添加上边框的更简洁方法；</p>
<pre><code>var t = document.getElementByTagName;
var arr=[];
arr.push.apply(arr,t.apply(document,[&quot;p&quot;]))  
arr.push.apply(arr,t.apply(document,[&quot;div&quot;]))

//ES5中有一个方法是forEach可以遍历；
arr.forEach(function(e){
    e.style.border=&quot;1px solid red&quot;
})       
</code></pre><h3 id="-">借用构造方法实现继承</h3>
<pre><code>function Foo(name,age,gender){
     this.name=name;
     this.age=age;
     this.gender=gender;
 }
 function Person(name,age,gender,hobby){
     foo.call(this,name,age,gender);
     this.hobby=hobby;
 }
 var p  = new Person(&quot;Jim&quot;,&quot;19&quot;,&quot;男&quot;,&quot;篮球&quot;);
 console.log(p);
</code></pre><h3 id="bind-">bind的用法</h3>
<blockquote>
<p>语法
函数.bind(对象)；
返回一个函数foo;
那么调用返回的函数 foo 就好像对象在调用该方法一样；</p>
</blockquote>
<hr>
<blockquote>
<p>bind就是让函数绑定对象的一种用法。
函数本身就是可以调用，但是其如果要作为方法调用，就必须传入宿主对象，并且使用call和apply形式。</p>
</blockquote>
<pre><code>//可以与上面做对比
var t = document.getElementByTagName.bind(document),
arr.push.apply( arr, t( &#39;p&#39; ) );
</code></pre><p>  arr.push.apply( arr, t( &#39;div&#39; ) );</p>
<p>  for ( var i = 0; i &lt; arr.length; i++ ) {
    arr[ i ].style.border = &#39;1px solid red&#39;;
  }</p>
<h3 id="-">四种函数调用模式</h3>
<p><strong>1.0 函数模式；</strong></p>
<blockquote>
<p>单独独立调用的就是函数模式</p>
</blockquote>
<hr>
<blockquote>
<p>函数的定义方式
1&gt;声明式
2&gt;表达式式
3&gt; Function</p>
</blockquote>
<p><strong>函数调用模式中this表示全局对象</strong></p>
<pre><code>  function test(){
   console.log(&quot;this:&quot;+this);
  }
   test ();
</code></pre><p><strong>2.0 方法模式；</strong></p>
<blockquote>
<p><strong>方法调用一定要有宿主对象</strong></p>
<p>方法一定是某个对象的方法，对象可以是任何对象</p>
</blockquote>
<pre><code>function test(){
    console.log(&quot;this:&quot;+this);
}
var o = {};
o.test = test;
o.test();
</code></pre><p><strong>函数调用模式与方法调用模式的面试题：</strong></p>
<pre><code>var length = 10;
function fn() {
    console.log(this.length);
}
var obj = {
    length: 5,
    method: function (fn) {
        fn();//fn()前面没有任何对象引导,所以此处为函数调用模式，this表示全局对象
        arguments[0]();
    }//这里为数组调用模式，属于方法调用模式的一种，this指向的是arguments这个伪数组,而this.length中length属性正好是一个内置的方法，所以打印出2
};
obj.method(fn, 1);  // 10 ,2 
</code></pre><p><strong>3.0 构造器模式；</strong></p>
<pre><code>function test(){
       console.log(&quot;this:&quot;+&quot;你是傻子哟&quot;)
   }
   var o = new test();
   console.log(o);
</code></pre><blockquote>
<p>返回值
如果不写return值，那么构造函数默认返回this
如果在构造函数上写上return，并且紧跟基本类型，则忽略返回类型：例如：</p>
</blockquote>
<pre><code> function foo(){
    return []
        }
  var o = new foo ;
  console.log(o)//结果是[]这个返回的引用类型       
</code></pre><blockquote>
<p>如果在构造函数中写上return语句，并且紧跟引用类型，那么构造函数返回该引用类型数据, 例如：</p>
</blockquote>
<pre><code> function foo(){
        return 123
            }
      var o = new foo ;
      console.log(o)//结果是foo这个函数
</code></pre><p><strong>4.0 上下文模式；</strong></p>
<pre><code>  function test(){
       console.log(&quot;this:&quot;+this)
   }
    var o = {};
    test.apply(o);
   console.log(o);
</code></pre><h3 id="-">有关函数调用模式和方法调用模式的经典面试题</h3>
<pre><code> function Foo(){
    getName = function(){ alert(1); };
    return this;
}

function getName(){
    alert(5);
}


Foo.getName = function(){ alert(2); };
Foo.prototype.getName = function(){ alert(3); };
getName = function(){ alert(4); };

Foo.getName();  //2
getName(); //4
Foo().getName();//1
getName();//1
new Foo.getName();//2
new Foo().getName();//3
new new Foo().getName();//3
</code></pre><h3 id="-">闭包的那点事儿</h3>
<ul>
<li><p><strong>那么什么是闭包呢？</strong></p>
<blockquote>
<p>闭包就是有权访问另一个函数作用域内变量的函数。</p>
</blockquote>
</li>
<li><p><strong>闭什么包包包？有什么用？</strong></p>
<p>  1.0 可以实现封装。
  2.0 缓存，可保留函数内部的值，始终保存在内存当中。
  3.0 匿名自执行函数 (function( ){ }) ( ); 创建了一个匿名的函数，并立即执行它，由于外部无法访问其变量，因此在执行完毕之后就会被释放，关键是这种机制不会污染全局</p>
</li>
<li><p><strong>废话不多说，就长这个样子！</strong></p>
<p>   function foo(){</p>
<pre><code>    var num = 123;
    return function( ){
        return num;
    };
 };
</code></pre></li>
</ul>
<p>-<strong>如果函数爸爸有俩变量儿子，怎么掏出来给人看</strong> </p>
<pre><code>function foo(){
  var num1 = 123;
  var num2 = 234;
 return {
  get_num1: function () {
    return num1;
  },
  get_num2: function () {
    return num2;
  }
 } 
 var o = foo();
</code></pre><p>  console.log( &#39;num1 = &#39; + o.get_num1() );
  console.log( &#39;num2 = &#39; + o.get_num2() );</p>
<p>-<strong>闭包可以造一个小黑屋，偷偷摸摸干坏事</strong></p>
<pre><code>(function () {
// 沙箱模式

// 所有的代码写在这里
</code></pre><p>  })();</p>

          	</article>
        </div>
		</div>
  </body>
</html>
<script type="text/javascript" src="toc/js/jquery-1.4.4.min.js"></script>
<script type="text/javascript" src="toc/js/jquery.ztree.all-3.5.min.js"></script>
<script type="text/javascript" src="toc/js/ztree_toc.js"></script>
<script type="text/javascript" src="toc_conf.js"></script>

<SCRIPT type="text/javascript" >
<!--
$(document).ready(function(){
    var css_conf = eval(markdown_panel_style);
    $('#readme').css(css_conf)
    
    var conf = eval(jquery_ztree_toc_opts);
		$('#tree').ztree_toc(conf);
});
//-->
</SCRIPT>